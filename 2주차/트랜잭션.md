# 6/29

## 트랜잭션

### 개념

> 인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야 하는 특성이자, 데이터베이스 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위이다.

쪼갤 수 없는 업무 처리의 최소 단위 / 거래내역

1초당 처리할 수 있는 트랜잭션의 개수를 **TPS**라고 한다.

간단하게 말해서 아래의 질의어(SQL)를 이용하여 데이터베이스를 접근 하는것을 의미한다.

- SELECT / INSERT / DELETE / UPDATE



트랜잭션 http://wiki.hash.kr/index.php/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98

---

### 특성

- **원자성(Atomicity)** - 트랜잭션의 **연산 전체가 성공 또는 실패**되어야 하는 성질 (All or Nothing)
  - Commit/Rollback , 회복성 보장
- **일관성(Consistency)** - 트랜잭션 수행 **전과** 트랜잭션 수행 **완료 후의 상태가 같아야** 하는 성질
  - 무결성 제약조건 , 동시성 제어
- **격리성, 고립성(Isolation)** - 동시에 실행되는 트랜잭션들이 **서로 영향을 미치지 않아야 한다**는 성질
  - Read Uncommitted, Read Committed, Repeatable Read, Serializable
- **영속성, 지속성(Durability)** - 성공이 완료된 트랜잭션의 결과는 **영속적으로 데이터베이스에 저장**되어야 하는 성질
  - 회복기법

---

### 트랜잭션의 상태 변화

![image](https://user-images.githubusercontent.com/97646054/176330106-5566655b-b73d-4cea-8945-38e70060c83f.png)

#### 수행 단계

- **실행(active)** - 트랜잭션을 실행 중
- **부분 완료(partially committed)** - DML 등 트랜잭션의 명령을 실행한 후의 상태
- **완료(committed = 커밋)** - 트랜잭션이 성공적으로 완료
- **실패(failed)** - 더 이상 정상적으로 실행될 수 없음을 발견
- **철회(aborted =롤백)** - 트랜잭션이 복원되어 트랜잭션 수행 이전 상태로 돌아감

---

### 트랜잭션 제어

> 트랜잭션 제어언어는 TCL(Transaction Control Language)라고 하며, 트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어를 지칭한다.



- **커밋(Commit)** - 트랜잭션을 메모리에 영구적으로 저장하는 명령어
  - 트랜잭션 확정
- **롤백(Rollback)** - 트랜잭션 내역의 저장을 무효화시키는 명령어
  - 트랜잭션 취소
- **체크포인트(Checkpoint)** - Rollback을 위한 시점을 지정하는 명령어
  - 저장 시기 설정

---

### 트랜잭션 스케줄

> 데이터베이스에서 여러 트랜잭션이 동시에 수행될 때, 수행되는 트랜잭션의 순서에 따라서 결과가 달라질 수 있다. 이때 처리하는 순서를 **스케줄**이라고 한다.



- **직렬(Serial) 스케줄** : 트랜잭션 별로 연산을 순차적으로 수행하는 것
- **비직렬(Non-Serial) 스케줄** : 인터리빙(Interleaving) 방식을 이용하여 트랜잭션들을 병행하여 수행하는 것
  - **인터리빙**(**interleaving**)의 사전적 의미는 '끼워 넣기'이다. **인터리빙**: IP 네트워크 즉 유선 통신 네트워크 또는 무선 통신 구간을 통하여 트래픽을 전송할 때, 발생할 수 있는, 군집 에러를 랜덤 에러로 변환하여, 에러 정정을 용이하게 하기 위하여 사용되는 기법.
- **직렬 가능(Serializable) 스케줄** : 직렬성을 가진 스케줄, 트랜잭션이 동시에 수행되더라도 직렬 스케줄과 동일한 결과를 갖는 것

---

### 충돌 직렬 가능

스케줄에 따라 결과가 달라지는 이유는 **충돌(Conflict)**이 발생하기 때문이다.
둘 이상의 트랜잭션에서 동일한 데이터에 접근할 때, <u>쓰기(write)연산이 하나라도 발생하면 충돌이 발생한다.</u>  연산의 순서를 바꾸면 결과가 달라질 수 있기 때문이다. 
만약 어떤 스케줄 S가 일련의 비충돌 명령어의 교환으로 스케줄 S'으로 변환될 수 있다면, S와 S'은 **충돌 동등(Conflict equivalent)**이라고 한다. 
그리고 S가 직렬 스케줄과 충돌 동등, 즉 동일한 결과를 갖는다면 S를 **충돌 직렬 가능(Conflict serializable)**이라고 한다. 

![image](https://user-images.githubusercontent.com/97646054/176367804-96a50c34-2cac-41d0-9452-9f0b7c8e272a.png)

위 그림과 같이 왼쪽의 스케줄이 오른쪽의 직렬 스케줄과 동일한 결과를 가지면 충돌 직렬 가능이라고 한다. 
만약 아래처럼 스케줄이 구성된 경우, 직렬 스케줄인 <T1, T2> or <T2, T1> 어느 쪽과도 결과가 일치하지 않으므로 충돌 직렬 가능이라고 할 수 없다. 

![image](https://user-images.githubusercontent.com/97646054/176367890-3fb01a93-f79d-4f84-9b23-f5f5eee38588.png)

---

### 뷰 직렬 가능

같은 트랜잭션 집합을 가진 두 스케줄 S와 S'이 다음 세 조건을 만족하면 S와 S'은 **뷰 동등(View equivalent)**이라고 한다. 



1) 데이터 x에 대하여 S에서 트랜잭션 Ti가 x의 초깃값을 읽는다면, S'에서도 Ti가 초깃값을 읽어야 한다. 
2) S에서 트랜잭션 Ti가 수행한 모든 read(x)의 연산 값이 Tj가 수행한 write(x)가 생성한 값이라면, S'에서 Ti가 수행한 모든 read(x)의 연산 값도 Tj가 수행한 write(x)가 생성한 값이어야 한다. 
3) S에서 Ti가 마지막 write(x)를 수행했다면, S'에서도 Ti가 마지막으로 write(x)를 수행해야 한다. 

즉, 동일한 데이터 x에 대해서 '최초 읽기', '쓰기/읽기', '마지막 쓰기'를 수행하는 트랜잭션의 순서가 동일해야 한다는 의미이다. 
그리고 마찬가지로 S가 직렬 스케줄과 뷰 동등이라면 S를 **뷰 직렬 가능(View conflict serializable)**이라고 한다. 



충돌 직렬 가능⊂뷰 직렬 가능

모든 충돌 직렬 가능 스케줄은 뷰 직렬 가능이며, 역은 성립하지 않는다. 아래가 예시이다.

![image](https://user-images.githubusercontent.com/97646054/176367963-e80ce949-f58e-434a-bb75-98a0fb253f38.png)

이 스케줄은 <T1, T2, T3> 직렬 스케줄과 뷰 동등이다. 조건 1과 3을 만족하고, write 연산 후의 read 연산이 없기 때문에 조건 2 또한 만족한다. 
반면 충돌 직렬 가능은 만족하지 않는다. 

---

### 병행 제어(일관성 주요 기법)

#### 1. 병행(Concurrency)이란

> 매우 빠르게 여러 트랜잭션 사이를 이동하면서 조금씩 처리를 수행하는 방식이다.
>
> 따라서 실제로는 한 번에 한 트랜잭션만 수행하지만, *<u>마치 동시에 여러 트랜잭션을 수행하는 것처럼</u>* 보이도록 하는 것이다.



> **병행 제어(Concurrency Control)**는 이렇게 *<u>트랜잭션이 병행 수행될 때 트랜잭션이 데이터베이스의 일관성을 파괴하지 않고, 다른 트랜잭션에 영향을 주지 않도록 트랜잭션 간의 상호작용을 제어하는 것</u>* 을 말한다.



#### 2. 목적

- 데이터베이스의 **공유를 최대화**한다.
- 시스템의 **활용도를 최대화**한다.
- 데이터베이스의 **일관성을 유지**한다.
- 사용자에 대한 **응답시간을 최소화**한다.
- 단위 시간당 트랜잭션 처리 건수 최대화



#### 3. 문제점

##### 1. 갱신 분실(Lost Update)

- 같은 데이터에 대해 둘 이상의 트랜잭션이 동시에 갱신할 때, 갱신 결과의 일부가 없어지는 현상

  ![image](https://user-images.githubusercontent.com/97646054/176371381-926bc0ee-6bb7-4478-b364-6324fd969ab3.png)

  > 두 개의 트랜잭션이 수행되고, 최종적인 결과로는 x에 800이 더해져야 한다. 
  > 하지만, 같은 데이터인 x에 대해서 트랜잭션 1이 갱신하기 이전에 트랜잭션 2가 x값을 받아와서 결국 최종 결과는 x + 500이 되어버린다. 
  > 이렇게 둘 이상의 트랜잭션이 동시에 같은 데이터를 갱신하면 올바르게 갱신되지 못한다. 

##### 2. 모순성(Inconsistency)

- 하나의 트랜잭션이 여러 데이터 갱신 연산을 수행할 때, 일관성 없는 상태의 데이터베이스에서 데이터를 가져옴으로써 데이터의 불일치가 발생하는 것

  ![image](https://user-images.githubusercontent.com/97646054/176371608-0096a5c2-0b0b-496e-bbac-586bc565fbba.png)

  > 트랜잭션 1이 완료되기 이전에 트랜잭션 2가 수행되는 모습이다.
  >
  > 따라서, 최종 결과로는 y에 500을 더해준 후 4를 곱한 결과가 나와야 하지만, 4를 곱한 y값에 500을 더하는 모순이 발생한다. 
  > 트랜잭션 2의 입장에서는 일관성이 유지되지만, 트랜잭션 1의 입장에서는 실행 전후 차이가 500 만큼이 발생해야 하는데 그보다 더 큰 차이가 발생하기 때문에 데이터의 불일치가 발생한다. 

##### 3. 연쇄 복귀(Cascading Rollback)

- 병행 수행되던 둘 이상의 트랜잭션 중 어느 한 트랜잭션에 오류가 발생하여 Rollback 하는 경우 다른 트랜잭션들도 함께 Rollback되는 현상

##### 4. 비완료 의존성 (uncommitted Dependency)

- 하나의 트랜잭션 수행이 실패한 후 회복하기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상

---

#### 4. 병행 제어 기법

##### 1. 로킹 (Locking)

로킹은 **트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는(lock) 병행 제어 기법**이다.
이를 통해 **상호 배제(Mutual Exclusive) 기능**을 제공하며, 잠금을 설정한 트랜잭션이 해제(unlock)할 때까지 데이터를 **독점적**으로 사용할 수 있다. 



<u>한 번에 로킹 할 수 있는 데이터의 크기</u>를 **로킹 단위**라고 하며 필드(Field), 레코드(Record), 테이블(Table), 파일(File), 데이터베이스(Database) 모두 로킹 단위가 될 수 있다. 



로킹 단위의 크기에 따라 성능의 차이가 발생한다.
****로킹 단위가 클수록 병행 제어가 단순해지고 관리하기가 편하지만 병행성 수준이 낮아진다.** 
반면 로킹 단위가 작을수록 병행 제어가 복잡해지고 오버헤드가 증가하지만, 병행성 수준이 높아지고 데이터베이스 공유도가 높아진다.** 



기본적으로 로킹은 **lock**과 **unlock** 연산을 사용한다. 로킹 규약은 다음과 같다. 

> 1) 트랜잭션 T가 공유 데이터 x를 접근하려면 먼저 lock(x)을 해야 한다.
> 2) 공유 데이터를 사용한 T는 반드시 unlock(x)을 해야 한다.
> 3) 다른 트랜잭션에 의해 lock(x)가 실행되었다면, 트랜잭션 T는 lock(x)을 실행하지 못한다.
> 4) 트랜잭션 T가 lock(x) 한 것을 다른 트랜잭션이 unlock(x)할 수 없다.
>



이러한 로킹 규약에는 제약이 있다. 
하나의 트랜잭션만이 공유 데이터를 사용할 수 있는데, 실제로 오직 읽기(read)만 하는 경우에는 동시에 접근해도 문제가 없기 때문에 이런 경우에 효율적이지 못하다.
따라서 위와 같은 문제점을 해결하기 위해 사용되는 것이 **2단계 로킹 규약**이다. 



로킹 기법은 **교착 상태(Dead lock)**가 발생할 수 있다는 한계가 있다. 
**교착 상태란, 여러 트랜잭션이 특정 데이터에 lock을 한 채 다른 트랜잭션이 lock을 수행한 데이터에 접근하려고 할 때 실행을 하지 못하고 서로 무한정 기다리는 상태를 말한다.** 

![image](https://user-images.githubusercontent.com/97646054/176373712-c1e89ea7-040e-4b5c-9c48-18806ae0b341.png)


위의 예시처럼, 트랜잭션 T1에서 x를 lock 하고 T2에서 y를 lock 한 경우에 T1도 y에 접근할 수 없고 T2도 x에 접근할 수 없다. 따라서 서로 무한정 기다리게 된다. 



##### 2. 2단계 로킹 규약 (Two-Phase Locking, 2PL)

2단계 로킹(Two-Phase Locking, 2PL) 규약은 **각 트랜잭션의 lock과 unlock 요청을 2단계로 실시하는 방식**이다.
단계는 확장 단계(Growing phase)와 축소 단계(shrinking phase)로 나뉜다. 
이를 통해 직렬성을 보장하는 대표적인 로킹 규약이지만 여전히 <u>lock 연산으로 인한 교착상태를 예방할 수는 없다</u>는 단점이 있다. 



> - 확장 단계(Growing phase) : 새로운 lock 연산만을 수행할 수 있고, unlock 연산은 수행할 수 없는 단계
> - 축소 단계(shrinking phase) : unlock 연산을 수행할 수 있고, lock연산은 수행할 수 없는 단계



2단계 로킹 규약은 **트랜잭션 내의 모든 lock 연산이 첫 번째 unlock 연산 이전에 위치해야 한다.** 따라서 하나의 트랜잭션에서 데이터에 대한 연산을 완전히 끝낸 후 unlock 하므로 직렬성이 보장된다. 
아래의 그림에서 왼쪽은 2단계 로킹 규약을 만족하는 경우, 오른쪽은 만족하지 않는 경우의 예시이다. 

![image](https://user-images.githubusercontent.com/97646054/176373830-964a73da-d98c-436b-9f8a-0de6cb7e38d2.png)

##### 3. 타임스탬프 순서 (Timestamp ordering) 기법

타임스탬프 순서 기법은 **비직렬 트랜잭션을 타임스탬프 순서에 따라 직렬화 시키는 방법**이다.
데이터에 접근하는 시간(Timestamp)을 미리 정해두어 부여된 시간 순서대로 데이터에 접근하며, lock을 사용하지 않고 시간을 나눠 사용하기 때문에 교착 상태(Dead lock)가 발생하지 않는다. 
하지만, <u>Rollback 발생률이 높고 연쇄 복귀를 초래할 수 있는 단점</u>이 있다. 

타임스탬프는 트랜잭션을 유일하게 식별할 수 있는 식별자의 역할을 할 수 있으며 트랜잭션의 시작 시간으로 간주할 수 있다. 타임스탬프를 생성하는 방법은 논리적 계수기(Logical Count) 또는 시스템 클럭(System Clock)을 이용한다. 

- **논리적 계수기** : 계수기를 사용하여 트랜잭션이 들어올 때마다 카운터를 하나씩 증가
- **시스템 클럭** : 시스템의 고유 시계 사용


타임스탬프 순서 기법의 운영 방식은 다음과 같다. 
read_TS(x) : read(x) 연산을 성공적으로 수행한 트랜잭션들의 타임스탬프 중 가장 큰 것
write_TS(x) : write(x) 연산을 성공적으로 수행한 트랜잭션들의 타임스탬프 중 가장 큰 것

1) **트랜잭션 T가 read(x)를 수행하려고 할 때**
  TS(T) < write_TS(x)이면, read(x)를 거부하고 T 취소 & 복귀
  TS(T) ≥ write_TS(x)이면, read(x)를 허용하고 read_TS(x) = TS(T)로 갱신
2) **트랜잭션 T가 write(x)를 수행하려고 할 때**
  TS(T) < read_TS(x)이면, write(x)를 거부하고 T 취소 & 복귀
  TS(T) < write_TS(x)이면, write(x)를 수행한 것으로 간주하고 무시(Thomas write rule, 트랜잭션 취소 감소 목적)
  이외의 경우, write(x)를 허용하고 write_TS(x) = TS(T)로 갱신 



##### 4. 낙관적 병행 제어 (Optimistic Concurrency Control)

낙관적 병행 제어는 **트랜잭션 수행 동안은 어떠한 검사를 하지 않고, 트랜잭션이 종료된 이후에 일괄적으로 검사하는 방식**이다. 수행 도중에는 트랜잭션을 위해 유지되는 데이터 항목들의 지역 사본에 대해서만 갱신하고, 트랜잭션이 종료되고 난 후에 직렬화를 검증하여 검증되면 데이터베이스에 한 번에 반영하는 방식이다. 
병행 수행하고자 하는 대부분의 트랜잭션이 판독 전용(Read-only)인 경우, 트랜잭션 간 충돌률이 매우 낮기 때문에 병행 제어 기법을 사용하지 않고도 대부분 일관성을 유지한다는 점을 이용한 방식이다. 



##### 5. 다중 버전 병행 제어 (Multi-version Concurrency Control)

**한 데이터에 대해 여러 버전의 값을 유지하며 관리하는 방식**이다. 타임스탬프의 개념을 이용하며, 다중 버전 타임 스탬프 기법이라고도 한다. 
여러 버전의 타임스탬프를 비교하여 스케줄상 직렬 가능성이 보장되는 타임스탬프를 선택한다. 
충돌이 발생할 경우 연쇄 복귀가 발생할 수 있는 단점이 있다.

---

### 트랜잭션 고립화 수준

**트랜잭션 고립화 수준(Transaction Isolation Level)**은 **트랜잭션의 독립성, 고립성을 유지하기 위해 데이터에 대한 접근을 허용하는 수준**을 말한다. 로킹(Locking) 기술을 기반으로 고립화 수준을 조정하며 총 4개의 레벨로 구성되어있다. 

고립화의 수준에 따라 발생할 수 있는 문제점들이 있는데, 수준이 높아질수록 문제점이 줄어드는 형태이다. 
다음과 같은 문제점들이 발생할 수 있다. 

1. **부정 판독(Dirty Read)**
   - 부정 판독은 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터를 읽는 것을 말한다.
   - 트랜잭션 T1이 특정 데이터를 갱신한 후 T2가 해당 데이터를 읽은 다음 T1이 Rollback 되면 T2는 존재하지 않은 값을 가리키게 되는 비일관된 상태에 놓이게 된다. 

2) **비반복 판독(Non-repeatable Read)**
   - 비반복 판독은 한 트랜잭션에서 같은 데이터를 두 번 이상 읽을 때, 중간에 다른 트랜잭션이 값을 갱신하거나 삭제함으로써 읽은 값이 서로 다르게 되는 현상이다. 

3) **팬텀 판독(Phantom Read)**
   - 팬텀 판독은 한 트랜잭션에서 같은 데이터를 두 번 이상 읽을 때, 중간에 다른 트랜잭션이 값을 추가함으로써 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상이다. 



##### 고립화 수준(Isolation Level) 의 유형

###### 1. Read uncommitted (Level 0)

**트랜잭션에서 아직 commit 되지 않고 처리 중인 데이터를 다른 트랜잭션이 읽을 수 있다.** 
부정 판독, 비반복 판독, 팬텀 판독 모두 발생하는 레벨이다. 
SELECT문을 수행하는 경우 해당 데이터에 Shared Lock이 걸리지 않는 레벨이다. 

###### 2. Read committed (Level 1)

**트랜잭션이 commit 된 데이터만 다른 트랜잭션이 읽을 수 있다.** 따라서 부정 판독(Dirty Read)을 방지해준다.
대부분의 DBMS에서 기본으로 채택하는 레벨이다. 

###### 3. Repeatable Read (Level 2)

**선행 트랜잭션이 데이터를 읽는 경우 종료 전까지 다른 트랜잭션의 갱신/삭제가 불가능하다.** 같은 레코드의 반복적인 판독은 동일한 값으로 반환된다. 따라서 비반복 판독(Non-repeatable Read)을 방지해준다. 

###### 4. Serializable (Level 3)

**선행 트랜잭션이 데이터를 읽는 경우 종료 전까지 다른 트랜잭션의 갱신/삭제/삽입이 불가능하다.** 따라서 새로운 레코드가 도중에 나타나지 않으므로 팬텀 판독(Phantom Read)을 방지해준다. 완벽한 정합성을 보장하는 레벨이다. 

![image](https://user-images.githubusercontent.com/97646054/176376124-e6321cb5-4cf6-447c-8c01-a3c96c109f15.png)

---

### 트랜잭션 회복 기법

트랜잭션에서의 **회복(recovery)**은 **트랜잭션이 실행되는 동안 발생한 오류로부터 가장 가까운 정상 상태로 복귀하는 것**이다. 주요 회복 기법으로 로그 기반, 검사점 기반, 그림자 페이지 사용 등이 있다.

**Undo** : 트랜잭션 로그를 이용하여 오류와 관련된 모든 변경을 취소하여 복구 수행
**Redo** : 트랜잭션 로그를 이용하여 오류가 발생한 트랜잭션을 재실행하여 복구 수행

#### 1. 로그 기반 회복

로그 기반 회복은 지연 갱신 회복과 즉시 갱신 회복으로 나뉜다.  

지연 갱신 회복은 트랜잭션이 부분 완료 상태에 이르기까지 발생한 모든 변경 내용을 로그 파일에만 저장하고 데이터베이스에는 커밋이 발생할 때까지 저장을 지연하는 방식이다. 따라서 중간에 장애가 발생하더라도 데이터베이스에 아직 기록되지 않았기 때문에 Undo 과정이 필요 없다. 

![image](https://user-images.githubusercontent.com/97646054/176376233-24e60eac-e776-49b3-8ef2-7f7e16b18400.png)

즉시 갱신 회복은 트랜잭션 수행 도중에 발생한 변경 내용을 로그 파일에 저장하고, 모든 변경 내용을 즉시 데이터베이스에 반영하는 방식이다. 트랜잭션 완료 이전에 수행된 갱신은 미완료 갱신이라고 하며, 회복하는 경우 Undo와 Redo를 모두 수행해야 한다. 

#### 2. 검사점 기반 회복

검사점 기반 회복은 체크포인트(Checkpoint) 회복이라고도 하며, 장애가 발생한 경우 검사점 이전에 처리된 트랜잭션은 제외하고 검사점 이후에 처리된 트랜잭션에 대해서만 회복 작업을 진행하는 방식이다. 

![image](https://user-images.githubusercontent.com/97646054/176376307-5798e379-0e48-440c-bc35-51212cb44b22.png)

위의 예시에서는 장애 이전의 가장 최근 검사점인 Checkpoint 2 이전의 트랜잭션 T1, T2, T3은 회복 작업에서 제외된다.
검사점 이후, 장애 발생 이전에 commit이 완료된 트랜잭션(T4, T5)은 Undo, 장애 발생 시점까지 commit 되지 못한 트랜잭션(T6)은 Redo를 수행한다.  



#### 3. 그림자 페이징 회복

그림자 페이징 회복은 현재 테이블은 주기억 장치, 그림자 페이지 테이블은 디스크에 저장하여 트랜잭션이 성공적으로 수행되는 경우 그림자 페이지 테이블을 삭제하고, 실패할 경우 그림자 페이지 테이블을 통해서 복구하는 방식이다. 
트랜잭션이 시작될 때 현재 테이블과 동일한 그림자 테이블을 생성한다. 



---

## 데이터 정의어

> (DDL: Data Definition Language) : DB를 구축하거나 수정할 목적으로 사용하는 언어

### 

### DDL 대상

- 도메인(Domain) : 하나의 속성이 가질 수 있는 원자값들의 집합
- 스키마(Schema) : 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조
  - 외부 스키마, 개념 스키마, 내부 스키마
- 테이블(Table) - 데이터 저장 공간
- 뷰(View) - 하나 이상의 물리 테이블에서 유도되는 가상의 테이블
- 인덱스(Index): 검색을 빠르게 하기 위한 데이터 구조
  - 순서 인덱스(Ordered Index): 데이터가 정렬된 순서로 생성되는 인덱스
  - 해시 인덱스(Hash Index): 해시 함수에 의해 직접 데이터에 키 값으로 접근하는 인덱스
  - 비트맵 인덱스(Bitmap Index) : Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 인덱스
  - 함수기반 인덱스(Functional Index): 수식이나 함수를 적용하여 만든 인덱스
  - 단일 인덱스(Single Index): 하나의 컬럼으로만 구성한 인덱스
  - 결합 인덱스(Concatenated Index): 두 개 이상의 컬럼으로 구성한 인덱스
  - 클러스터드 인덱스(Clustered Index): 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
  - 넌클러스터드 인덱스(Non-Clustered Index) : 인덱스의 키 값만 정렬되어 있고 실제 데이터는 정렬되지 않는 방식 ( 데이터 삽입, 삭제 시 데이터 재정렬해야 함)

#### DDL 명령어

CREATE(생성), ALTER(수정), DROP(삭제)

- CASCADE : 제거할 요소를 참조하는 다른 모든 개체를 함께 제거
- RESTRICT : 다른 개체가 제거할 요소를 참조중일 때는 제거를 취소



## 데이터 조작어

> (DML: Data Manipulation Language) : 저장된 데이터를 실질적으로 관리하는데 사용되는 언어



- DML 유형: SELECT(조회), INSERT(삽입), UPDATE(수정), DELETE(삭제)



## 데이터 제어어

> (DCL: Data Control Language) : 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는데 사용하는 언어

- DCL 유형
  - GRANT : 사용 권한 부여
  - REVOKE : 사용 권한 취소
